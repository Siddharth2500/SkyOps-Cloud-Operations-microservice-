# -*- coding: utf-8 -*-
"""SkyOps (Cloud + Operations microservice)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y1sEyvWd3UiDWmKNrdVAn4E3hqiXSSDK
"""

# ===== SkyOps (Cloud + Operations microservice) — Colab one-cell setup & run =====
# This creates a complete project at /content/skyops and starts the server on port 8001.

import os, textwrap, sys, subprocess, threading, time

PROJECT_ROOT = "/content/skyops"
os.makedirs(PROJECT_ROOT, exist_ok=True)

def write(path, content):
    full = os.path.join(PROJECT_ROOT, path)
    os.makedirs(os.path.dirname(full), exist_ok=True)
    with open(full, "w", encoding="utf-8") as f:
        f.write(textwrap.dedent(content).lstrip())

# ---------------- app/main.py ----------------
write("app/main.py", r"""
from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse, PlainTextResponse
from pydantic import BaseModel
import os, time, json, uuid, asyncio, platform, psutil  # psutil via requirements
from prometheus_client import Counter, Histogram, Gauge, generate_latest, CONTENT_TYPE_LATEST

APP_NAME = os.getenv("APP_NAME", "SkyOps")
ENV = os.getenv("ENVIRONMENT", "dev")
VERSION = os.getenv("APP_VERSION", "1.0.0")

app = FastAPI(title=APP_NAME, version=VERSION)

# ---------------- Metrics ----------------
REQ_COUNTER = Counter("skyops_http_requests_total", "Total HTTP requests", ["method", "path", "status"])
REQ_LATENCY = Histogram("skyops_http_request_duration_seconds", "HTTP request latency seconds", ["method", "path"])
CPU_GAUGE = Gauge("skyops_cpu_percent", "Process CPU percent")
MEM_RSS_GAUGE = Gauge("skyops_memory_rss_bytes", "Process Resident Set Size bytes")

# ---------------- Models ----------------
class LoadRequest(BaseModel):
    seconds: float = 5.0
    parallelism: int = 1

# ---------------- Helpers ----------------
def safe_env():
    """Return safe environment info without secrets."""
    allow = {"ENVIRONMENT", "APP_VERSION", "APP_NAME"}
    out = {}
    for k, v in os.environ.items():
        if k in allow:
            out[k] = v
    return out

def json_log(message: str, **extra):
    payload = {"message": message, "app": APP_NAME, "env": ENV, **extra}
    print(json.dumps(payload), flush=True)

@app.middleware("http")
async def observability_middleware(request: Request, call_next):
    rid = request.headers.get("x-request-id", str(uuid.uuid4()))
    start = time.time()
    response: Response = await call_next(request)
    dur = time.time() - start
    REQ_LATENCY.labels(request.method, request.url.path).observe(dur)
    REQ_COUNTER.labels(request.method, request.url.path, str(response.status_code)).inc()
    response.headers["x-request-id"] = rid
    json_log(
        "request_completed",
        method=request.method,
        path=str(request.url.path),
        status=response.status_code,
        duration_ms=int(dur * 1000),
        request_id=rid,
    )
    return response

@app.on_event("startup")
async def on_startup():
    json_log("startup", version=VERSION, python=platform.python_version())
    # Prime psutil
    psutil.Process().cpu_percent(interval=None)

@app.on_event("shutdown")
async def on_shutdown():
    json_log("shutdown")

@app.get("/")
def root():
    return {"app": APP_NAME, "env": ENV, "version": VERSION, "message": "SkyOps operational service"}

@app.get("/health")
def health():
    return {"status": "ok"}

@app.get("/ready")
def ready():
    # Could check external deps here
    return {"ready": True}

@app.get("/status")
def status():
    p = psutil.Process()
    mem = p.memory_info().rss
    cpu = p.cpu_percent(interval=0.05)
    CPU_GAUGE.set(cpu)
    MEM_RSS_GAUGE.set(mem)
    return {
        "app": APP_NAME,
        "env": ENV,
        "version": VERSION,
        "host": platform.node(),
        "python": platform.python_version(),
        "process": {"cpu_percent": cpu, "rss_bytes": mem},
        "env_info": safe_env(),
    }

@app.post("/simulate-cpu")
async def simulate_cpu(req: LoadRequest):
    """Burn CPU cycles to demo HPA/autoscaling behavior."""
    async def burn(seconds: float):
        end = time.time() + seconds
        # Busy loop
        while time.time() < end:
            _ = 3.14159 ** 2.71828
            # Tiny await to yield back occasionally
            if int(time.time() * 1000) % 100 == 0:
                await asyncio.sleep(0)

    tasks = [asyncio.create_task(burn(req.seconds)) for _ in range(max(1, req.parallelism))]
    await asyncio.gather(*tasks)
    return {"status": "done", "seconds": req.seconds, "parallelism": req.parallelism}

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

@app.get("/logs/example", response_class=PlainTextResponse)
def logs_example():
    """Show sample JSON log lines to illustrate structure."""
    lines = [
        json.dumps({"message": "demo_log", "event": "deploy", "app": APP_NAME, "env": ENV}),
        json.dumps({"message": "demo_log", "event": "scale", "replicas": 3, "app": APP_NAME}),
    ]
    return "\n".join(lines)
""")

# ---------------- tests/test_health.py ----------------
write("tests/test_health.py", r"""
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_health():
    r = client.get("/health")
    assert r.status_code == 200
    assert r.json() == {"status": "ok"}

def test_ready():
    r = client.get("/ready")
    assert r.status_code == 200
    assert r.json()["ready"] is True
""")

# ---------------- requirements.txt ----------------
write("requirements.txt", r"""
fastapi==0.111.0
uvicorn[standard]==0.30.0
pydantic==1.10.14
prometheus_client==0.20.0
pytest==8.2.1
httpx==0.27.0
psutil==5.9.8
""")

# ---------------- Dockerfile ----------------
write("Dockerfile", r"""
FROM python:3.11-slim
WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY app ./app
EXPOSE 8001
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8001"]
""")

# ---------------- .dockerignore ----------------
write(".dockerignore", r"""
__pycache__
*.pyc
*.pyo
*.pyd
*.log
.env
.venv
dist
build
.coverage
""")

# ---------------- .gitignore ----------------
write(".gitignore", r"""
__pycache__/
*.py[cod]
.venv/
.env
dist/
build/
.coverage
pytestcache/
*.log
""")

# ---------------- Makefile ----------------
write("Makefile", r"""
run:
	uvicorn app.main:app --host 0.0.0.0 --port 8001 --reload

test:
	pytest -q

docker-build:
	docker build -t skyops:latest .

docker-run:
	docker run -p 8001:8001 skyops:latest
""")

# ---------------- k8s/deployment.yaml ----------------
write("k8s/deployment.yaml", r"""
apiVersion: apps/v1
kind: Deployment
metadata:
  name: skyops
  labels:
    app: skyops
spec:
  replicas: 2
  selector:
    matchLabels:
      app: skyops
  template:
    metadata:
      labels:
        app: skyops
    spec:
      containers:
      - name: skyops
        image: ghcr.io/YOUR_GH_USERNAME/skyops:latest
        ports:
        - containerPort: 8001
        env:
        - name: APP_NAME
          value: "SkyOps"
        - name: ENVIRONMENT
          value: "prod"
        readinessProbe:
          httpGet: { path: /ready, port: 8001 }
        livenessProbe:
          httpGet: { path: /health, port: 8001 }
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "256Mi"
""")

# ---------------- k8s/service.yaml ----------------
write("k8s/service.yaml", r"""
apiVersion: v1
kind: Service
metadata:
  name: skyops
spec:
  selector:
    app: skyops
  ports:
  - port: 80
    targetPort: 8001
    protocol: TCP
  type: ClusterIP
""")

# ---------------- README.md (short pointer) ----------------
write("README.md", r"""
# SkyOps — Cloud & Ops microservice

See the full README in the next cell of your notebook. This repo exposes health/ready/metrics, status,
and CPU simulation to demonstrate autoscaling/observability patterns.
""")

print("✔ Project files created at", PROJECT_ROOT)

# -------- Install deps --------
print("⏳ Installing dependencies...")
subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", os.path.join(PROJECT_ROOT, "requirements.txt")])

# -------- Start server (port 8001) --------
import uvicorn, nest_asyncio
nest_asyncio.apply()

def run_server():
    uvicorn.run("app.main:app", host="0.0.0.0", port=8001, reload=False, app_dir=PROJECT_ROOT, log_level="info")

t = threading.Thread(target=run_server, daemon=True)
t.start()
time.sleep(2)

print("\n🚀 SkyOps running at http://127.0.0.1:8001")
print("   Try quick checks from Python below...")

import httpx
print("GET /health ->", httpx.get("http://127.0.0.1:8001/health", timeout=5).json())
print("GET /status ->", httpx.get("http://127.0.0.1:8001/status", timeout=5).status_code)